"use strict";(self.webpackChunkcosmwasmsauru=self.webpackChunkcosmwasmsauru||[]).push([[6864],{7661:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core/architecture/transactions","title":"Transactions","description":"Every contract invocation is wrapped into a transaction. If you know about transactions in SQL","source":"@site/docs/core/architecture/transactions.md","sourceDirName":"core/architecture","slug":"/core/architecture/transactions","permalink":"/docs/core/architecture/transactions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Pinning","permalink":"/docs/core/architecture/pinning"},"next":{"title":"Conventions","permalink":"/docs/core/conventions/"}}');var r=n(4848),o=n(8453);const a={sidebar_position:6},c="Transactions",i={},l=[{value:"Dispatching Submessages",id:"dispatching-submessages",level:2},{value:"Preventing rollbacks in case of failure",id:"preventing-rollbacks-in-case-of-failure",level:2},{value:"Order of execution and rollback procedure",id:"order-of-execution-and-rollback-procedure",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"transactions",children:"Transactions"})}),"\n",(0,r.jsx)(t.p,{children:"Every contract invocation is wrapped into a transaction. If you know about transactions in SQL\ndatabases, you can consider them as the same basic concept. You execute multiple operations in a\nsingle transaction, and if one of them fails, the whole transaction is rolled back."}),"\n",(0,r.jsx)(t.p,{children:"In our case, these operations are invocations of contract entrypoints. If one of the invocations in\nthe chain fails, the whole transaction is usually rolled back. Failing in this context means that\nthe contract entrypoint returns an error or panics."}),"\n",(0,r.jsx)(t.h2,{id:"dispatching-submessages",children:"Dispatching Submessages"}),"\n",(0,r.jsxs)(t.p,{children:["Now let's move onto the ",(0,r.jsx)(t.code,{children:"messages"})," field of the\n",(0,r.jsx)(t.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.Response.html",children:(0,r.jsx)(t.code,{children:"Response"})}),". Some contracts\nare fine only talking with themselves. But many want to move tokens or call into other contracts for\nmore complex actions. This is where messages come in. We return\n",(0,r.jsx)(t.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/enum.CosmosMsg.html",children:(0,r.jsx)(t.code,{children:"CosmosMsg"})}),", which is a\nserializable representation of any external call the contract can make."]}),"\n",(0,r.jsxs)(t.p,{children:["This may be hard to understand at first. \"Why can't I just call another contract?\", you may ask.\nHowever, we do this to prevent one of the most widespread and hardest to detect security holes in\nEthereum contracts - reentrancy. We do this by following the actor model, which doesn't nest\nfunction calls, but returns messages that will be executed later. This means all state that is\ncarried over between one call and the next happens in storage and not in memory. For more\ninformation on this design, I recommend you read ",(0,r.jsx)(t.a,{href:"./actor-model",children:"our docs on the Actor Model"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["A common request was the ability to get the result from one of the messages you dispatched. For\nexample, you want to create a new contract with\n",(0,r.jsx)(t.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/enum.WasmMsg.html#variant.Instantiate",children:(0,r.jsx)(t.code,{children:"WasmMsg::Instantiate"})}),",\nbut then you need to store the address of the newly created contract in the caller. This is possible\nwith ",(0,r.jsx)(t.code,{children:"messages"})," and replies. This makes use of\n",(0,r.jsx)(t.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/enum.CosmosMsg.html",children:(0,r.jsx)(t.code,{children:"CosmosMsg"})})," as above, but it\nwraps it inside a ",(0,r.jsx)(t.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.SubMsg.html",children:(0,r.jsx)(t.code,{children:"SubMsg"})}),"\nenvelope."]}),"\n",(0,r.jsxs)(t.p,{children:["What are the semantics of a submessage execution? First, we create a sub-transaction context around\nthe state, allowing it to read the latest state written by the caller, but write to yet-another\ncache. If ",(0,r.jsx)(t.code,{children:"gas_limit"})," is set, it is sandboxed to how much gas it can use until it aborts with\n",(0,r.jsx)(t.code,{children:"OutOfGasError"}),". This error is caught and returned to the caller like any other error returned from\ncontract execution (unless it burned the entire gas limit of the transaction)."]}),"\n",(0,r.jsxs)(t.p,{children:["If it returns success, the temporary state is committed (into the caller's cache), and the\n",(0,r.jsx)(t.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.Response.html",children:(0,r.jsx)(t.code,{children:"Response"})})," is processed as\nnormal. Once the response is fully processed, this may then be intercepted by the calling contract\n(for ",(0,r.jsx)(t.code,{children:"ReplyOn::Always"})," and ",(0,r.jsx)(t.code,{children:"ReplyOn::Success"}),"). On an error, the subcall will revert any partial\nstate changes due to this message, but not revert any state changes in the calling contract. The\nerror may then be intercepted by the calling contract (for ",(0,r.jsx)(t.code,{children:"ReplyOn::Always"})," and ",(0,r.jsx)(t.code,{children:"ReplyOn::Error"}),").\nIn this case, the message's error doesn't abort the whole transaction."]}),"\n",(0,r.jsxs)(t.p,{children:["Note, that error doesn't abort the whole transaction ",(0,r.jsx)(t.em,{children:"if and only if"})," the ",(0,r.jsx)(t.code,{children:"reply"})," is called - so in\ncase of ",(0,r.jsx)(t.code,{children:"ReplyOn::Always"})," and ",(0,r.jsx)(t.code,{children:"ReplyOn::Error"}),". If the submessage is called with ",(0,r.jsx)(t.code,{children:"ReplyOn::Success"}),"\nor ",(0,r.jsx)(t.code,{children:"ReplyOn::Never"}),", the error in a subsequent call would result in failing whole transaction and\nnot commit the changes for it. The rule here is as follows: if for any reason you want your message\nhandling to succeed on submessage failure, you always have to reply on failure."]}),"\n",(0,r.jsx)(t.h2,{id:"preventing-rollbacks-in-case-of-failure",children:"Preventing rollbacks in case of failure"}),"\n",(0,r.jsxs)(t.p,{children:["If you don't want your entire transaction to be rolled back in case of a failure, you can split the\nlogic into multiple messages. This can be two contracts, a contract executing itself or a contract\nthat sends a message to a Cosmos SDK module. Then use the ",(0,r.jsx)(t.code,{children:"reply_on"})," field in the message you send.\nSet the field to one of the following values and instead of rolling back the transaction, you will\nreceive a message containing the error:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"ReplyOn::Always"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"ReplyOn::Error"})}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"That way you can handle the error and decide what to do next, whether you want to propagate the\nerror, retry the operation, ignore it, etc."}),"\n",(0,r.jsxs)(t.p,{children:["The default value ",(0,r.jsx)(t.code,{children:"ReplyOn::Success"})," means the caller is not ready to handle an error in the message\nexecution and the entire transaction is reverted on error."]}),"\n",(0,r.jsx)(t.h2,{id:"order-of-execution-and-rollback-procedure",children:"Order of execution and rollback procedure"}),"\n",(0,r.jsxs)(t.p,{children:["Submessages handling follows ",(0,r.jsx)(t.em,{children:"depth first"})," order rules. Let's see the following example scenario:"]}),"\n",(0,r.jsx)(t.mermaid,{value:"  sequenceDiagram\n    Note over Contract 1: Contract 1 returns two submessages:<br/> 1. Execute Contract 2<br/> 2. Execute Contract 4\n    Contract 1->>Contract 2: 1. Execute\n    Note over Contract 2: Contract 2 returns one submessage:<br/> 1. Execute Contract 3\n    Contract 2->>Contract 3: 2. Execute\n    Contract 3->>Contract 2: 3. Response\n    Note over Contract 2: Contract 2 can handle the Response<br/>in the reply entrypoint or leave it\n    Contract 2->>Contract 1: 4. Response\n    Note over Contract 1: Contract 1 can handle the Response<br/>in the reply entrypoint or leave it\n    Contract 1->>Contract 4: 5. Execute\n    Contract 4->>Contract 1: 6. Response\n    Note over Contract 1: Contract 1 can handle the Response<br/>in the reply entrypoint or leave it"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Note 1"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.SubMsgResponse.html#structfield.msg_responses",children:"msg_responses"}),"\nof the response are not forwarded down the call path. It means that for e.g. if ",(0,r.jsx)(t.code,{children:"Contract 2"})," will not\nexplicitly handle response from ",(0,r.jsx)(t.code,{children:"Contract 3"})," and forward any data, then ",(0,r.jsx)(t.code,{children:"Contract 1"})," will never learn\nabout results from ",(0,r.jsx)(t.code,{children:"Contract 3"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Note 2"})}),"\n",(0,r.jsxs)(t.p,{children:["If ",(0,r.jsx)(t.code,{children:"Contract 2"})," returns an error, the error message can be handled by the ",(0,r.jsx)(t.code,{children:"Contract 1"}),"\nreply entrypoint and prevent the whole transaction from rollback. In such a case only the\n",(0,r.jsx)(t.code,{children:"Contract 2"})," and ",(0,r.jsx)(t.code,{children:"Contract 3"})," states changes are reverted."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var s=n(6540);const r={},o=s.createContext(r);function a(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);