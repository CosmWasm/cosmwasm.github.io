"use strict";(self.webpackChunkcosmwasmsauru=self.webpackChunkcosmwasmsauru||[]).push([[6440],{5365:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"core/entrypoints/migrate","title":"Migrate","description":"This is another special entrypoint. It is, just like instantiate, not called frequently.","source":"@site/docs/core/entrypoints/migrate.md","sourceDirName":"core/entrypoints","slug":"/core/entrypoints/migrate","permalink":"/docs/core/entrypoints/migrate","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Query","permalink":"/docs/core/entrypoints/query"},"next":{"title":"Sudo","permalink":"/docs/core/entrypoints/sudo"}}');var s=t(4848),o=t(8453);const a={sidebar_position:4},i="Migrate",d={},l=[{value:"Example",id:"example",level:2},{value:"Definition",id:"definition",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"migrate",children:"Migrate"})}),"\n",(0,s.jsxs)(n.p,{children:["This is another special entrypoint. It is, just like ",(0,s.jsx)(n.a,{href:"./instantiate",children:"instantiate"}),", not called frequently."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"migrate"})," is only called once you upload a new version of your contract to the chain\nand lets you run all the required changes to the storage."]}),"\n",(0,s.jsx)(n.p,{children:"Let's say your storage has the following layout, expressed as JSON for simplicity:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="structure.json"',children:'{\n  "user_count": 205,\n  "call_count": 543,\n  "balance": 43\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"But then you notice \"Hey! Why don't I nest all the counts into an own object? That way I don't have\nthat redundant postfix, making the keys smaller\"."}),"\n",(0,s.jsx)(n.p,{children:"So you go ahead and rework your logic to query the data from the following structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="structure.json"',children:'{\n  "count": {\n    "user": 205,\n    "call": 543\n  },\n  "balance": 43\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"But your storage on chain still stores the old format. You need to transform it somehow."}),"\n",(0,s.jsxs)(n.p,{children:["That's what you do in the ",(0,s.jsx)(n.strong,{children:"migrate"})," entrypoint. You transform the structure of the storage."]}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsxs)(n.p,{children:["For CosmWasm ",(0,s.jsx)(n.code,{children:"v2.2.0"})," and newer, the new migrate info feature can be used:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Rust",metastring:'title="contract.rs"',children:'const MIGRATE_VERSION: u64 = 2;\n\n#[cfg_attr(not(feature = "library"), entry_point)]\n#[migrate_version(MIGRATE_VERSION)]\npub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg, migrate_info: MigrateInfo) -> StdResult<Response> {\n    match migrate_info.old_migrate_version {\n      Some(1) | None => {\n        // If the old on-chain version of the contract don\'t use the\n        // `migrate_version` macro, there will be no version provided here\n        // (it\'s the `None` variant).\n\n        // Load the old data\n        let Some(old_data) = deps.storage.get(b"persisted_data") else {\n          return Err(StdError::generic_err("Data not found"));\n        };\n        // Deserialize it from the old format\n        let old_data: OldData = cosmwasm_std::from_json(&old_data)?;\n\n        // Transform it\n        let new_data = transform(old_data);\n\n        // Serialize the new data\n        let new_data = cosmwasm_std::to_json_vec(&new_data)?;\n        // Store the new data\n        deps.storage.set(b"persisted_data", &new_data);\n      }\n      Some(x) if x >= MIGRATE_VERSION => {\n        // Assume we don\'t support downgrading the contract\'s state version\n        // Note that `migrate_info.old_migrate_version` is never eq to `MIGRATE_VERSION`.\n        return Err(StdError::generic_err("Downgrades are not supported for this contract."));\n      }\n      _ => {\n        return Err(StdError::generic_err("Unexpected migrate version."));\n      }\n    }\n    Ok(Response::default())\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For CosmWasm versions before ",(0,s.jsx)(n.code,{children:"v2.2.0"})," the old method looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Rust",metastring:'title="contract.rs"',children:'const STATE_VERSION: &str = "v2";\nconst CONTRACT_NAME: &str = "my_contract";\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -> StdResult<Response> {\n    // Check if the state version is older than the current one and update it\n    cw2::ensure_from_older_version(deps.storage, CONTRACT_NAME, STATE_VERSION)?;\n\n    // Load the old data\n    let Some(old_data) = deps.storage.get(b"persisted_data") else {\n      return Err(StdError::generic_err("Data not found"));\n    };\n    // Deserialize it from the old format\n    let old_data: OldData = cosmwasm_std::from_json(&old_data)?;\n\n    // Transform it\n    let new_data = transform(old_data);\n\n    // Serialize the new data\n    let new_data = cosmwasm_std::to_json_vec(&new_data)?;\n    // Store the new data\n    deps.storage.set(b"persisted_data", &new_data);\n\n    Ok(Response::default())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(n.p,{children:["To get the additional migrate info, the new signature can be used (CosmWasm ",(0,s.jsx)(n.code,{children:"v2.2.0"})," and newer):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Rust",metastring:'title="contract.rs"',children:'const MIGRATE_VERSION: u64 = 2;\n\n#[cfg_attr(not(feature = "library"), entry_point)]\n#[migrate_version(MIGRATE_VERSION)]\npub fn migrate(\n    deps: DepsMut,\n    env: Env,\n    msg: MigrateMsg,\n    migrate_info: MigrateInfo) -> StdResult<Response> {\n    // TODO: Put your migration logic here.\n    Ok(Response::default())\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The legacy CosmWasm (before version ",(0,s.jsx)(n.code,{children:"v2.2.0"}),") migrate entrypoint function signature is defined like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Rust",metastring:'title="contract.rs"',children:'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn migrate(\n    deps: DepsMut,\n    env: Env,\n    msg: MigrateMsg) -> StdResult<Response> {\n    // TODO: Put your migration logic here.\n    Ok(Response::default())\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(6540);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);