"use strict";(self.webpackChunkcosmwasmsauru=self.webpackChunkcosmwasmsauru||[]).push([[4371],{6063:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core/entrypoints/reply","title":"Reply","description":"The reply entrypoint is another special one.","source":"@site/docs/core/entrypoints/reply.md","sourceDirName":"core/entrypoints","slug":"/core/entrypoints/reply","permalink":"/docs/core/entrypoints/reply","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Sudo","permalink":"/docs/core/entrypoints/sudo"},"next":{"title":"Semantics","permalink":"/docs/core/architecture/semantics"}}');var r=s(4848),o=s(8453);const i={sidebar_position:6},a="Reply",c={},l=[{value:"Request a reply",id:"request-a-reply",level:2},{value:"Definition",id:"definition",level:2},{value:"Handling the reply",id:"handling-the-reply",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"reply",children:"Reply"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"reply"})," entrypoint is another special one."]}),"\n",(0,r.jsx)(n.p,{children:"It relates to CosmWasm's actor model which dictates how you call other contracts and interact with them."}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["If you are not familiar with the actor model, you can find out more about it on ",(0,r.jsx)(n.a,{href:"../architecture/actor-model",children:"its own page"}),"."]})}),"\n",(0,r.jsx)(n.p,{children:"This endpoint gets invoked when you receive a response to a message you sent out over the chain.\nThe reply parameter then allows you to inspect and work with the response that was produced."}),"\n",(0,r.jsx)(n.h2,{id:"request-a-reply",children:"Request a reply"}),"\n",(0,r.jsxs)(n.p,{children:["To request a reply, you need to use the ",(0,r.jsx)(n.code,{children:"reply_on"})," field in the message you send and set it to one\nof the following values:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ReplyOn::Always"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ReplyOn::Error"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ReplyOn::Success"})}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"reply_on"})," value has an impact on when a transaction is cancelled.\nFor more info, check the page about ",(0,r.jsx)(n.a,{href:"../architecture/transactions",children:"transactions"}),"."]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-Rust",metastring:'title="contract.rs"',children:'const CONTRACT_ADDR: &str = "other_contract";\nconst SUBMSG_ID: u64 = 1; // This is a unique identifier so we can associate a reply with a specific submessage. It can be any numeric value.\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn reply(deps: DepsMut, env: Env, msg: cosmwasm_std::Reply) -> StdResult<Response> {\n    if msg.id != SUBMSG_ID {\n        return Err(StdError::generic_err("Invalid submsg id"));\n    }\n\n    // We received a message! From the contract we invoked earlier.\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, msg: ExecuteMsg) -> StdResult<Response> {\n    let msg = WasmMsg::Execute {\n        contract_addr: CONTRACT_ADDR.into(),\n        msg: to_json_binary(&OtherContractMsg::DoSomething {}).unwrap(),\n        funds: vec![],\n    };\n\n    let submsg = SubMsg::reply_always(msg, SUBMSG_ID);\n    Ok(Response::new().add_submessage(submsg))\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-Rust",metastring:'title="contract.rs"',children:'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn reply(\n    deps: DepsMut, \n    env: Env, \n    msg: cosmwasm_std::Reply) -> StdResult<Response> {\n    // TODO: Put you reply logic here.\n    Ok(Response::default())\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"handling-the-reply",children:"Handling the reply"}),"\n",(0,r.jsxs)(n.p,{children:["Once the submessage handling is finished, the caller will get a chance to handle the result.\nIt will get the original ",(0,r.jsx)(n.code,{children:"id"})," of the subcall and the ",(0,r.jsx)(n.code,{children:"Result"})," of the execution, both success and error.\nNote that it includes all events returned by the submessage, which applies to native SDK modules\n(like bank) as well as the contracts. If you need more state, you must save it in the local store during\nthe ",(0,r.jsx)(n.code,{children:"execute"})," entrypoint call, and load it in the ",(0,r.jsx)(n.code,{children:"reply"})," entrypoint."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"reply"})," call may return ",(0,r.jsx)(n.code,{children:"Err"})," itself, in which case it is treated like the caller errored,\nand aborting the sub-transaction. However, on successful processing, ",(0,r.jsx)(n.code,{children:"reply"})," may return a normal\n",(0,r.jsx)(n.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.Response.html",children:(0,r.jsx)(n.code,{children:"Response"})}),", which will be\nprocessed as normal - events added to the ",(0,r.jsx)(n.code,{children:"EventManager"}),", and all ",(0,r.jsx)(n.code,{children:"messages"})," dispatched as described above.\nWhen ",(0,r.jsx)(n.code,{children:"Err"})," is returned by a message handler, all changes made by the handler up to the reply\nentrypoint that returns the ",(0,r.jsx)(n.code,{children:"Ok"})," response are reverted. More information can be found in the following section."]}),"\n",(0,r.jsxs)(n.p,{children:["The responses emitted by the submessage are gathered in the\n",(0,r.jsx)(n.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.SubMsgResponse.html#structfield.msg_responses",children:(0,r.jsx)(n.code,{children:"msg_responses"})}),"\nfield of the ",(0,r.jsx)(n.a,{href:"https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.SubMsgResponse.html",children:"SubMsgResponse"})," structure.\n",(0,r.jsx)(n.strong,{children:"wasmd"})," allows chains to translate a single contract message into multiple SDK messages.\nIn that case all the message responses from each are concatenated into this flattened ",(0,r.jsx)(n.code,{children:"Vec"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var t=s(6540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);