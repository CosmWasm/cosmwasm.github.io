"use strict";(self.webpackChunkcosmwasmsauru=self.webpackChunkcosmwasmsauru||[]).push([[5100],{6331:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"core/architecture/semantics","title":"Semantics","description":"This document provides an explanation of the semantics governing the interaction between","source":"@site/docs/core/architecture/semantics.md","sourceDirName":"core/architecture","slug":"/core/architecture/semantics","permalink":"/docs/core/architecture/semantics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Semantics","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Reply","permalink":"/docs/core/entrypoints/reply"},"next":{"title":"Actor model","permalink":"/docs/core/architecture/actor-model"}}');var i=n(4848),o=n(8453);const a={title:"Semantics",sidebar_position:1},r="Contract semantics",c={},h=[{value:"Definitions",id:"definitions",level:2},{value:"SDK Context",id:"sdk-context",level:3}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"contract-semantics",children:"Contract semantics"})}),"\n",(0,i.jsx)(t.p,{children:"This document provides an explanation of the semantics governing the interaction between\nthe CosmWasm contract and its environment."}),"\n",(0,i.jsx)(t.h2,{id:"definitions",children:"Definitions"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Contract"})," is a ",(0,i.jsx)(t.a,{href:"https://webassembly.org/",children:"WebAssembly"})," code stored in the blockchain's state. This has no state except\nthat which is contained in the binary code (e.g. static constants)."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Instance"})," refers to a specific instantiation of a contract. It includes a reference to the\ncontract's binary as well as a state unique to the instance, which is initialized upon its creation.\nThis state is stored in the key-value store on the blockchain's state. Consequently, a reference to\nthe contract's binary, combined with a reference to the prefixed data store, uniquely identifies the\nsmart contract."]}),"\n",(0,i.jsx)(t.p,{children:'Example: we could upload a generic "ERC20 mintable" contract, and many people could create independent\ninstances of this contract based on the same bytecode, where the local data defines the token name,\nthe issuer, the max issuance, etc.'}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["First you ",(0,i.jsx)(t.strong,{children:"store"})," a ",(0,i.jsx)(t.em,{children:"contract"})," on chain."]}),"\n",(0,i.jsxs)(t.li,{children:["Then you ",(0,i.jsx)(t.strong,{children:"instantiate"})," an ",(0,i.jsx)(t.em,{children:"instance"})," of the contract."]}),"\n",(0,i.jsxs)(t.li,{children:["Finally, users ",(0,i.jsx)(t.strong,{children:"invoke"})," the ",(0,i.jsx)(t.em,{children:"instance"})," of the contract."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"sdk-context",children:"SDK Context"}),"\n",(0,i.jsxs)(t.p,{children:["Before looking at CosmWasm, we should look at the semantics enforced by the blockchain framework we\nintegrate with - the ",(0,i.jsx)(t.a,{href:"https://docs.cosmos.network/",children:"Cosmos SDK"}),". It is based upon the ",(0,i.jsx)(t.a,{href:"https://tendermint.com/core/",children:"Tendermint BFT"})," consensus engine.\nLet us first look how they process transactions before they arrive in CosmWasm."]}),"\n",(0,i.jsxs)(t.p,{children:["First, the Tendermint engine will seek >2/3 consensus on a list of transactions to be included in\nthe next block. This is done ",(0,i.jsx)(t.em,{children:"without executing them"}),". They are simply subjected to a minimal\npre-filter by the Cosmos SDK module, to ensure they are validly formatted transactions, with\nsufficient gas fees, and signed by an account with sufficient fees to pay it. Notably, this means\nmany transactions that error may be included in a block."]}),"\n",(0,i.jsxs)(t.p,{children:["Once a block is committed, the transactions are then fed to the Cosmos SDK sequentially in order to\nexecute them. Each one returns a result or error along with event logs, which are recorded in the\n",(0,i.jsx)(t.code,{children:"TxResults"})," section of the next block. The ",(0,i.jsx)(t.code,{children:"AppHash"})," (or merkle proof or blockchain state) after\nexecuting the block is also included in the next block."]}),"\n",(0,i.jsxs)(t.p,{children:["The Cosmos SDK ",(0,i.jsx)(t.code,{children:"BaseApp"}),' handles each transaction in an isolated context. It first verifies all\nsignatures and deducts the gas fees. It sets the "Gas Meter" to limit the execution to the amount of\ngas paid for by the fees. Then it makes an isolated context to run the transaction. This allows the\ncode to read the current state of the chain (after the last transaction finished), but it only\nwrites to a cache, which may be committed or rolled back on error.']}),"\n",(0,i.jsxs)(t.p,{children:["A transaction may consist of multiple messages and each one is executed in turn under the same\ncontext and same gas limit. If all messages succeed, the context will be committed to the underlying\nblockchain state and the results of all messages will be stored in the ",(0,i.jsx)(t.code,{children:"TxResult"}),". If one message\nfails, all later messages are skipped and all state changes are reverted. This is very important for\natomicity. That means Alice and Bob can both sign a transaction with 2 messages: Alice pays Bob 1000\nATOM, Bob pays Alice 50 ETH, and if Bob doesn't have the funds in his account, Alice's payment will\nalso be reverted. This is similar to how a database transaction typically works."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://github.com/CosmWasm/wasmd/tree/master/x/wasm",children:(0,i.jsx)(t.code,{children:"x/wasm"})})," is a custom Cosmos SDK module,\nwhich processes certain messages and uses them to upload, instantiate, and execute smart contracts.\nIt accepts a properly signed\n",(0,i.jsx)(t.a,{href:"https://github.com/CosmWasm/wasmd/blob/master/proto/cosmwasm/wasm/v1/tx.proto",children:(0,i.jsx)(t.code,{children:"CosmWasm message"})}),",\nroutes it to ",(0,i.jsx)(t.a,{href:"https://github.com/CosmWasm/wasmd/blob/master/x/wasm/keeper/keeper.go",children:(0,i.jsx)(t.code,{children:"Keeper"})}),",\nwhich loads the proper smart contract and calls one of the entry-point on it. Note that this method\nmay either return a success (with data and events) or an error. In the case of an error here, it\nwill revert the entire transaction in the block."]}),"\n",(0,i.jsxs)(t.p,{children:["For more information on contracts design visit ",(0,i.jsx)(t.a,{href:"../entrypoints",children:"entrypoints"})," chapter."]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(6540);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);